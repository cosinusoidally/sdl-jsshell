Problem statement is in ./README.txt . This file details the plan and progress
towards a fix.

Plan
====

Restructure the main loop to look something like this:

while(running){
  while(SDL_PollEvent(...)){
    // process all events in the queue, draining the whole queue in the process.
  }
  render(); // draw our frame;
  wait(); // where wait will wait for the next frame.
}

The wait function needs to get woken up each time our frame timer fires. To do
this it will wait on a condition variable. Something like this:

function wait(){
  SDL_CondWait(cond, mut);
}

SDL_CondWait will block until the condition varable is signalled (with
SDL_CondSignal).

* cond is our condition variable (we never actually modify this variable, we
  just wait on it).
* mut is SDL_mutex mutex object. During initialisation of our app we will lock
  this by the main thread and never permanently unlock it for the duration of
  the program (SDL_CondWait will temporarily unlock it, but it locks it again
  after SDL_CondWait returns).

As you can see all wait does it wait for SDL_CondWait to unblock. To unblock
SDL_CondWait we must call SDL_CondSignal from a timer callback function.


To setup our timer we schedule a periodic timer with SDL_AddTimer. The callback
will do 2 things:

* call SDL_CondSignal on a condition variable
* return the same interval value (this schedules the next timer callback)

The callback function cannot be written in JS (since the timer callback happens
from a different thread and in Spidermonkey jsctypes callbacks cannot be called
from a different thread).

Similar to v0.0.2 I'll generate a bit of machine code, load it in to RAM, patch
it up from JS, and then pass it to SDL_AddTimer as the callback function.


Progress
========

DONE
====

In progress atm

IN-PROGRESS
===========

* write a dummy version of wait. This will allow me to move on to restructing
  the main loop before moving on to implementing the condition variable version
  of wait. The dummy version can just poll Date.now() until enough time
  elapses.

TODO
====

* restructure sdl.sdl_mainloop as per above plan
* create condition variable and mutex. This will require binding a few more SDL
  funtions to JS. Namely:
  SDL_CreateMutex
  SDL_CreateCond
  SDL_CondWait (only need the address of this one to pass to our timer callback)
  
  and for the manipulation of the mutex:
  SDL_mutexP (we will use this to lock the mutex)
  SDL_mutexV (to unlock the mutex, probably not needed)
* Create a shared library written in C that is our timer callback.
* Write code to load in our shared library
* Wire up our timer callback function
* Reimplement wait to use SDL_CondWait
* Replace our shared library with small chunks of machine code that are loaded
  and patched up by JS (this is to avoid depending on needing a C compiler, or
  the need to distribute a binary .dll or .so file). This will be done in much
  the same way as v0.0.2 does it for its timer callbacks.
